<!doctype html>
<html>

<head>
    <title>The history of Promises</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8" />
    <link rel="stylesheet" href="post.css">
    <style>
        img {
            border: solid 1px #ccc;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: inline-block;
            width: 100%;
        }

        .image {
            max-width: 720px;
            max-height: 405px;
            position: relative;
            padding-bottom: 58.334%;
        }

        .image-container {
            max-width: 720px;
            max-height: 405px
        }

        @media (prefers-color-scheme: dark) {
            body {
                background: #1f1f1f;
                color: #fff
            }

            a,
            a:visited {
                color: #74abff;
            }
        }
    </style>
</head>

<body>
    <article>
        <h1>A Brief history of promises</h1>
        <p>
            <b>I Promise.</b>
        </p>
        <div class="image-container">
            <div class="image">
                <img src="history-of-promises-assets/slide-2.jpg"
                    alt="i promise, a brief history of the promise .. i promise" />
            </div>
        </div>
        <p>
            Promises are older than you think - they originate from
            an idea born during the start of the <a target="_blank" rel="noopener"
                href="https://en.wikipedia.org/wiki/Space_Race">space
                race</a>. I want to tell you a story of
            how a concept from the 1960s made its way into your JS runtime.</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img src="history-of-promises-assets/slide-3.jpg" alt="sync and async" />
            </div>
        </div>
        <p>Before we begin, it is important that we establish the difference between sync
            actions and async actions. Now, we could talk about code and implementation
            details, but I find an analogy to be better suited for this task.</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img src="history-of-promises-assets/slide-4.jpg" alt="driving a car, cars driving across the image" />
            </div>
        </div>
        <p>If you frame the world and everything that we do as us interacting with an
            asynchronous entity the distinction becomes easier to reason about. Picture
            yourself driving a car down the road: you are listening to the radio, staying in
            your lane, and carrying on a conversation with the passenger next to you. Now you
            feel the urge to sneeze, and as we all know sneezing is the last thing you want
            to be doing when you are driving. Try as you might you cannot stop yourself from
            sneezing, and there you go - you sneeze and close your eyes. Everything else you
            are doing at that moment does not &quot;Stop&quot; - it continues on - but you are
            stuck in the sneezing state: frozen, eyes shut, driving at 65 miles per hour.</p>
        <p>Sneezing is what I would call a synchronous real world action: when you are
            sneezing nothing else matters because THAT IS ALL YOU ARE DOING.</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-5.jpg" alt="#include <stdio.h>
                    int main()
                    {
                        printf("hi \n");
                        usleep(100 * 100)
                        printf("bye \n");

                        return 0;
                    }" />
                <noscript>
                    <img src="history-of-promises-assets/slide-5.jpg" alt="#include <stdio.h>
                        int main()
                        {
                            printf("hi \n");
                            usleep(100 * 100)
                            printf("bye \n");
    
                            return 0;
                        }" />
                </noscript>
            </div>
        </div>
        <p>Let me illustrate the point in code. Here you can see we print "hello", sleep for a while and then print
            "bye". While we are asleep nothing else is going on in the program, it is just
            sitting there, waiting - doing nothing else. When the process completes we continue on with our
            program. <strong>The Important thing</strong> to take away here is the fact that while we are
            asleep, <strong>NOTHING</strong> is happening in our program, <strong>Nothing can happen at all</strong> given this
            paradigm. This is an important concept to keep in mind as we wander onto this
            winding and murky async history path.</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-6.jpg"
                    alt="devtools showing a native Promise when printed to the screen" />
                <noscript>
                    <img src="history-of-promises-assets/slide-6.jpg"
                        alt="devtools showing a native Promise when printed to the screen" />
                </noscript>
            </div>
        </div>
        <p>Opening our browser console today and typing Promise, we are greeted by a
            Promise constructor. We can resolve this promise with our friend the horse, and
            we can reject a promise with some fire. </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-7.jpg"
                    alt="can i use support for Promise, showing almost all green" />
                <noscript>
                    <img src="history-of-promises-assets/slide-7.jpg"
                        alt="can i use support for Promise, showing almost all green" />
                </noscript>
            </div>
        </div>
        <p>And no this is not just nightly Chrome, this is a very very well supported API,
            that you can use today without polyfills and without vendor scripts in both the
            browser and in Node. </p>
        <p>So you are thinking of course Sam, tell me something I do not already know jesh.
            But I want to point out that being able to use this API is not the novel thing,
            the novel thing is asking yourself <em>Why can I do this today?</em><br>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-8.jpg" alt="why can i do this today?" />
                <noscript>
                    <img src="history-of-promises-assets/slide-8.jpg" alt="why can i do this today?" />
                </noscript>
            </div>
        </div>
        </p>
        <p>How did these 7 letters ("Promise") get joined together so precariously and yield such a useful
            and powerful thing? </p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-9.jpg"
                    alt="ryan dahl original node.js presentation 2009" />
                <noscript>
                    <img src="history-of-promises-assets/slide-9.jpg"
                        alt="ryan dahl original node.js presentation 2009" />
                </noscript>
            </div>
        </div>
        <p>Ryan Dahl first presented Node.js in 2009, which as you know was one of the biggest shifts in JavaScript
            development since Brendan Eich wrote the initial implementation of JavaScript. In his presentation at
            JSConf, this early version version of Node had Promises… well at least what they called
            &quot;Promises&quot;... Of course I wanted to find out exactly what this implementation looked like so
            I cloned the Node.js repo to take a look at the logs (FAIR WARNING - this repo is kinda big and it took
            30 minutes :( so I do not really recommend that you do it)</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-10.jpg"
                    alt="original nodejs github commit for promises" />
                <noscript>
                    <img src="history-of-promises-assets/slide-10.jpg"
                        alt="original nodejs github commit for promises" />
                </noscript>
            </div>
        </div>
        <p>Looking at the repo we can see that in June 2009 the initial commit was landed
            for Promises… let's go one step further and see how it was implemented.</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-11.jpg"
                    alt="original nodejs promise implementation using event emitters" />
                <noscript>
                    <img src="history-of-promises-assets/slide-11.jpg"
                        alt="original nodejs promise implementation using event emitters" />
                </noscript>
            </div>
        </div>
        <p>Oh, here it is. Wait though… this is not a promise implementation, this is just an event emitter
            wrapped up in a promise-like interface. But what was the intent and where did
            this idea come from?</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-12.jpg" alt="where did this come from?" />
                <noscript>
                    <img src="history-of-promises-assets/slide-12.jpg" alt="where did this come from?" />
                </noscript>
            </div>
        </div>
        <p>What is the lineage of this idea of a promise?</p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-13.jpg"
                    alt="timeline showing the different promise implementations" />
                <noscript>
                    <img src="history-of-promises-assets/slide-13.jpg"
                        alt="timeline showing the different promise implementations" />
                </noscript>
            </div>
        </div>
        <p>
            It was pretty tricky, however through the extensive use of wayback machine, emails, and personal interviews I was
            able to piece together a reasonable history all the way from the early origins of Promises to the ES2015 spec. </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-14.jpg" alt="mercury space program 1961" />
                <noscript>
                    <img src="history-of-promises-assets/slide-14.jpg" alt="mercury space program 1961" />
                </noscript>
            </div>
        </div>
        <p>To set the scene, this tale of the promises starts in 1961. In 1961, NASA was
            busy with the Mercury space program, racing into space to catch up to Russia
            after their somewhat surprise launch of Sputnik 1.
            <a href="https://en.wikipedia.org/wiki/Ham_(chimpanzee)">Ham
                the
                chimp</a> had just returned from a successful trip into
            space, and was on the cover of LIFE.</p>
        <p>Ok… enough with Ham the chimp. Back to Promises we go…<br>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-15.jpg" alt="algol thunks, 1961" />
                <noscript>
                    <img src="history-of-promises-assets/slide-15.jpg" alt="algol thunks, 1961" />
                </noscript>
            </div>
        </div><br>In 61, along came a paper written about Algol - short for algorithmic language -
        and was published in ACM. This paper described a method of compiling procedural statements.
        I won't bore you with the details because I know everyone in the room here is super
        familiar with algol already, but the important concept discussed in this paper
        comes down to this idea of a &quot;Thunk&quot;</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-16.jpg"
                    alt="a thunk is a piece of coding which priceds an address. when executed, it leaves in some standard location" />
                <noscript>
                    <img src="history-of-promises-assets/slide-16.jpg"
                        alt="a thunk is a piece of coding which priceds an address. when executed, it leaves in some standard location" />
                </noscript>
            </div>
        </div>
        <p>A thunk is a compile time optimization which provides an address. When this thunk
            is executed, some value will eventually be available at some standard location
            (or at the given address). Now why is this important and what does this mean? This
            &quot;thunk&quot; thing is the concept that a value reference will eventually be stored in
            a given location at some time in the future. This should sound somewhat familiar
            to the basic idea of a promise -- a value that will eventually represent some value in the future. </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-17.jpg" alt="1977 star wars box office" />
                <noscript>
                    <img src="history-of-promises-assets/slide-17.jpg" alt="1977 star wars box office" />
                </noscript>
            </div>
        </div>
        <p>If we hop into the Delorean and fast forward to 1977, the first Star Wars had
            just been released and an equally important concept was introduced. <a
                href="https://web.archive.org/web/20150501065726/http://home.pipeline.com/~hbaker1/Futures.html">A
                paper</a>
            outlining the concept of a "future" was published. </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-18.jpg" alt="futures 1977" />
                <noscript>
                    <img src="history-of-promises-assets/slide-18.jpg" alt="futures 1977" />
                </noscript>
            </div>
        </div>
        <p>While this paper was about approaches for dealing with garbage collection, it
            has a few novel ideas that drove inspiration for future iterations on the
            concept of eventual values, and remote execution of functions. </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-19.jpg"
                    alt="...allows the fully parallel evaluation of arguments to a function" />
                <noscript>
                    <img src="history-of-promises-assets/slide-19.jpg"
                        alt="...allows the fully parallel evaluation of arguments to a function" />
                </noscript>
            </div>
        </div>
        <p>In the paper abstract right away the author throws out this concept of a
            parallel evaluation of arguments to a function. This idea in the JavaScript
            world is nothing new this actually feels like a pretty recognizable concept. We
            want to eval multiple things at the same time and in parallel. Much like a
            webworker allows us to do… The notable thing is that this is in 1977, not 2016.<br>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-20.jpg"
                    alt="in call-by-future, each format parameter of a function is bound to a seperate function (called a future)" />
                <noscript>
                    <img src="history-of-promises-assets/slide-20.jpg"
                        alt="in call-by-future, each format parameter of a function is bound to a seperate function (called a future)" />
                </noscript>
            </div>
        </div>
        </p>
        <p>The paper goes further and outlines the approach of taking each of the params
            and binding them to a separate process. Here in lies the essential concept, as
            soon as we allow individual params to be handled by different processes there is
            nothing holding back the evaluation and running of each of params values&quot; in
            parallel and in a way that does not block each other. Now if you are like me, you
            are thinking why do I care about params, those are just values… however if you
            shift your perception of values to something different -- think of params here as
            not just flat values but potentially other functions and other &quot;eventual&quot;
            values. </p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-21.jpg"
                    alt="joule channels, channels are message plumbing to connect servers, a joule computation is a dataflow diagram spread out in space, 1995" />
                <noscript>
                    <img src="history-of-promises-assets/slide-21.jpg"
                        alt="joule channels, channels are message plumbing to connect servers, a joule computation is a dataflow diagram spread out in space, 1995" />
                </noscript>
            </div>
        </div>
        <p>In 1995, the Joule language was introduced, intended to be a new model for building distributed systems.
            The entire model was that of a making building distributed systems simple. Every action in Joule consisted
            of sending and receiving messages from servers. A "channel" was the abstraction or message plumbing through
            which the messages are conveyed. It was in this way that Joule set the stage for a formal message pattern.
            This idea of a middleman or relay entity that was responsible for delegating async communication instead
            of an event based pattern meant that the data and its flow was predictable, which allowed you to treat these
            entities as just another pattern for passing data around, even though they were async under the hood.</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-22.jpg"
                    alt="e lang, first non-blocking promise impl - 1997" />
                <noscript>
                    <img src="history-of-promises-assets/slide-22.jpg"
                        alt="e lang, first non-blocking promise impl - 1997" />
                </noscript>
            </div>
        </div>
        <p>The culmination of these ideas and the true watershed moment which inspired the
            majority of Future/Promise implementations is in E. While E introduced many concepts,
            we will only look at a specific subset of the language - the Promise implementation.
            E was the first implementation of promises that was truly non-blocking, in that the
            work that was being done &quot;Remotely&quot; would never block the future execution.</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-23.jpg"
                    alt="diagram showing the relationship between resolved and broken state of a promise" />
                <noscript>
                    <img src="history-of-promises-assets/slide-23.jpg"
                        alt="diagram showing the relationship between resolved and broken state of a promise" />
                </noscript>
            </div>
        </div>
        <p>E also established a lexicon, shown in the diagram above. With a few minor wording
            adjustments, this diagram maps 1:1 to what JavaScript promises are today. This
            diagram comes from the original E language paper and description by Mark Miller.
            You will note that it treats local promises and remote promises as the same thing,
            just as Joule treated all messages as &quot;channels&quot; and futures were
            potentially going to enable the fully parallel execution across multiple
            processes. E builds on these ideas and treats the idea of a Promise as agnostic to
            where the work is actually being done. A last interesting note about this original
            design is that while the original name for a promise in a failed state was
            &quot;broken&quot;, which was fine in other languages, this would not work in
            JavaScript… why not? &quot;broken&quot; =&gt; break … break is a reserved word in
            JS… so this was changed to .catch() instead.</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-25.jpg"
                    alt="python twisted deferred, attended to mirror E promises- 2001" />
                <noscript>
                    <img src="history-of-promises-assets/slide-25.jpg"
                        alt="python twisted deferred, attended to mirror E promises- 2001" />
                </noscript>
            </div>
        </div>
        <p>Python&#39;s Twisted framework directly derived their future/deferred implementation
            From the E language. This implementation, while not capturing the entire idea of
            E&#39;s promises, brought along enough of the concepts to be the seed from which the
            JS implementations grew.</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-26.jpg" alt="the grand JS port" />
                <noscript>
                    <img src="history-of-promises-assets/slide-26.jpg" alt="the grand JS port" />
                </noscript>
            </div>
        </div>
        <p>From this point forward we will be following the JavaScript track of the story - it is
            important to note however that the implementation path in other languages was
            running in parallel and in some ways was more &quot;correct&quot; during this time period. </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-27.jpg" alt="twisted to MochiKit 2005" />
                <noscript>
                    <img src="history-of-promises-assets/slide-27.jpg" alt="twisted to MochiKit 2005" />
                </noscript>
            </div>
        </div>
        <p>The first implementation in JS that I could find that followed the ethos of E
            promises was found in
            <a href="https://github.com/mochi/mochikit/commit/fd638aacdf062e0ff424a02248ef7456b8c5311e#diff-391bd7b533356bb0ed11bf5281ed3011R62">MochiKit</a>.
            MochiKit (extracted from
            <a href="https://web.archive.org/web/20140404201229/http://www.mochibot.com/">MochiBot</a>)
            by Bob Ippolito, was a direct port from Twisted. When
            I reached out to Bob asking where he got the idea for this implementation he
            noted that he directly ported the implementation from Python&#39;s Twisted lib.</p>
        <p>What I find so perfect about our communication is the rationale for why he
            ported this functionality (since it really has stood the test of time)</p>
        <p>
            <quote> MochiBot used a lot of AJAX style calls and Deferred made that much easier
                to work with than directly using XMLHTTPREQUEST</quote>
        </p>
        <p>And as he pointed out…</p>
        <p>
            <quote> It can&#39;t have been that bad of an idea since today&#39;s fetch API provides a
                HTTP interface that returns a promise.</quote>
        </p>
        <p>Keep in mind this was in 2005… this async problem that to this day is
            troublesome was being felt and dealt with before I even started seriously
            programming. </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-28.jpg" alt="dojo deferredRequest 2006" />
                <noscript>
                    <img src="history-of-promises-assets/slide-28.jpg" alt="dojo deferredRequest 2006" />
                </noscript>
            </div>
        </div>
        <p>In
            <a
                href="https://github.com/comfuture/numbler/blob/16cb2364c298472ba38edab96ef630a00467ef40/numbler/dojo/src/rpc/DeferredRequest.js">2006</a>
            (or perhaps earlier since I think the commit date is lying about the date due to
            the bulk import from SVN), the Dojo Toolkit team checked in deferredRequest. So I guess in
            this case Dojo did not do it first ;)... But they did do it quite early. </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-29.jpg" alt="dojo deferred 2007" />
                <noscript>
                    <img src="history-of-promises-assets/slide-29.jpg" alt="dojo deferred 2007" />
                </noscript>
            </div>
        </div>
        <p>Further searching of the underbelly of the internet yielded additional interesting
            finds in Dojo land. In 2007 Alex Russell
            <a
                href="https://github.com/dojo/dojo/commit/2e82010b8ff5a2493bc1fd0991a89492e426d61b#diff-81a2b6cf414b75fe76524c2902a90d7a">decoupled</a>
            the Deferred idea from deferredRequest.
            In a <a href="http://thread.gmane.org/gmane.comp.web.dojo.devel/841/focus=843">listserve
                post</a> from
            2006 Alex also mentioned the inspiration for the deferred request as coming from
            Mochikit and Python&#39;s Twisted implementation.</p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-30.jpg" alt="waterken Q - early 2009" />
                <noscript>
                    <img src="history-of-promises-assets/slide-30.jpg" alt="waterken Q - early 2009" />
                </noscript>
            </div>
        </div>
        <p>Early 2009 was the moment where promise adoption to surged, going from niche to mainstream. While <a target="_blank" rel="noopener"
                href="https://github.com/kriskowal/q">Q</a> may be somewhat familiar to you, there was an
            earlier version called <a target="_blank" rel="noopener" href="http://waterken.sourceforge.net/web_send/#API">Waterken
                Q</a> that has a lot of syntax
            familiarity with newer libs like modern Q and when.js. The implementation self identified as a
            &quot;concise and expressive API for interacting with JSON resources&quot; </p>

        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-31.jpg" alt="promise proposal - march 24 2009" />
                <noscript>
                    <img src="history-of-promises-assets/slide-31.jpg" alt="promise proposal - march 24 2009" />
                </noscript>
            </div>
        </div>
        <p>In 2009
            <a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!topic/commonjs/6T9z75fohDk"> Kris Zyp
                proposed</a> adding Promises
            as an official API in the CommonJS mailing this. To many this was the
            start of Promises landing in the spec. In his post he notes the influences of
            Waterken Q.</p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-32.jpg" alt="The Q awakening september 3 2009" />
                <noscript>
                    <img src="history-of-promises-assets/slide-32.jpg" alt="The Q awakening september 3 2009" />
                </noscript>
            </div>
        </div>
        <p>
            In <a target="_blank" rel="noopener"
                href="https://github.com/kriskowal/q/commit/9191ce4c803cc3f8a01fb6c3a428ac57c9a83d3f">September of
                2009</a>
            Kris Kowal (also on the Promise API thread) took the ideas of waterken Q along with the design and goals of
            E to
            create the popular Q lib.
        </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-34.jpg"
                    alt="dojo deferred to promise naming - september 17 2009" />
                <noscript>
                    <img src="history-of-promises-assets/slide-34.jpg"
                        alt="dojo deferred to promise naming - september 17 2009" />
                </noscript>
            </div>
        </div>
        <p>
            8 days later, Dojo
            <a href="http://mail.dojotoolkit.org/pipermail/dojo-contributors/2009-September/021017.html">
                began the
                conversation</a>
            to go from the idea of a deferred to the idea of a Promise.</p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-35.jpg" alt="the rise of JQuery 2010" />
                <noscript>
                    <img src="history-of-promises-assets/slide-35.jpg" alt="the rise of JQuery 2010" />
                </noscript>
            </div>
        </div>
        <p>
            In <a target="_blank" rel="noopener"
                href="https://github.com/jquery/jquery/commit/5bacb53866dbc3fbb36202a25c756a4ea2fd5965">December
                of
                2010</a>, deferreds landed in jQuery core, but were not yet exposed externally as
            an API. The promise interface was eventually exposed in the $.ajax API - anyone
            programming JavaScript at the time most likely has this burned into their memory.<br>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-36.jpg"
                    alt="github commit adding promises to jquery core 2010" />
                <noscript>
                    <img src="history-of-promises-assets/slide-36.jpg"
                        alt="github commit adding promises to jquery core 2010" />
                </noscript>
            </div>
        </div>
        </p>
        <p>This simple API single-handedly papered over the friction of
            <a target="_blank" rel="noopener"
                href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a>,
            at the same time introducing the concept of &quot;eventual resolution&quot; as a
            happy side-effect. </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-37.jpg" alt="$.ajax().done()" />
                <noscript>
                    <img src="history-of-promises-assets/slide-37.jpg" alt="$.ajax().done()" />
                </noscript>
            </div>
        </div>
        <p>Keep in mind during this time the web was rapidly moving forward, HTML5 was
            coming and more and more new web APIs were shipping: Webcrypto, fetch, IndexedDB,
            localStorage. Each of these APIs had to figure out what to do regarding
            asynchronous actions. Some opted to use promise-like interfaces, others
            callbacks, and some event emitters. This disconnect became especially
            complicated when different promise implementations were added to the mix.</p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-38.jpg" alt="briar patch of apis" />
                <noscript>
                    <img src="history-of-promises-assets/slide-38.jpg" alt="briar patch of apis" />
                </noscript>
            </div>
        </div>
        <p>The promises spec was simple but the lack of a unified test suite was making
            different implementations not work together. <a target="_blank" rel="noopener" href="https://github.com/tchak">Paul
                Chavard</a> lead the way with the idea of introducing a
            test suite for Promise contract fulfillment. Paul created
            <a target="_blank" rel="noopener" href="https://github.com/emberjs/ember.js/pull/1406">a pull request to
            Ember</a> to
            introduce a Promise
            test suite. </p>
        <p>Domenic Denicola, recognizing the shortcomings of the implementation, went ahead
            and created the A+ promise doc and test suite the day that the Ember PR landed.
            (hear him tell the story
            <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=V2Q13hzTGmA&amp;app=desktop">here</a>).<br>

        </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-39.jpg" alt="an A+ unification" />
                <noscript>
                    <img src="history-of-promises-assets/slide-39.jpg" alt="an A+ unification" />
                </noscript>
            </div>
        </div>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-41.jpg" alt="50+ A+ implementations" />
                <noscript>
                    <img src="history-of-promises-assets/slide-41.jpg" alt="50+ A+ implementations" />
                </noscript>
            </div>
        </div>
        <p>This test suite and spec lead to 50+ compatible Promise implementations, a massive
            win for the community since it meant that you did not have to worry about different
            async / deferred / promise implementations. So long as the implementation was A+
            you knew that they would be compatible at the .then level. The meta win here was
            the fact that having multiple agreeing implementations showed the TC39 that there
            was community consensus around the idea of Promises… an idea that a few years
            earlier was thought to be too esoteric for common use. </p>
        <p>
        <div class="image-container">
            <div class="image">
                <img lazyimg="history-of-promises-assets/slide-42.jpg" alt="promises landed in es2015 by tc39 - 2015" />
                <noscript>
                    <img src="history-of-promises-assets/slide-42.jpg" alt="promises landed in es2015 by tc39 - 2015" />
                </noscript>
            </div>
        </div>
        <p>Because of the community buy-in and eventual need for other async operations
            like module loading in ES2015 (called ES6 at the time), Promises were
            fast-tracked and landed, with much thanks to Domenic Denicola.</p>
        <p>So here we are in 2020 using an API that is the composite of ideas and work
            starting in 1961, spanning multiple programming languages and generations.</p>
        <hr>
        <p>
            Special thanks to Kris Kowal, Mark Miller, Rebecca Murphey, Alex Russell, and Domenic Denicola for their
            help in reconstructing this timeline. Additional thanks to Karl Horky for the editing help.
        </p>
        <hr>
        Sam Saccone <a href="http://twitter.com/samccone" target="_blank" rel="noopener">@samccone</a>
    </article>

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-100642-4"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'UA-100642-4');

        (function () {
            if (typeof IntersectionObserver === "undefined") {
                return;
            }

            const observer = new IntersectionObserver(e => onHit(e, observer), {
                rootMargin: '0px',
                threshold: 0
            });

            for (const img of document.querySelectorAll('img[lazyimg]')) {
                observer.observe(img);
            }

            /**
             * @param {IntersectionObserverEntry[]} entries 
             * @param {IntersectionObserver} observer
             */
            function onHit(entries, observer) {
                for (const e of entries) {
                    if (e.isIntersecting) {
                        observer.unobserve(e.target);
                        e.target.setAttribute('src', e.target.getAttribute('lazyimg'));
                        e.target.removeAttribute('lazyimg');
                    }
                }
            }

        })()

    </script>

</body>
</html>
